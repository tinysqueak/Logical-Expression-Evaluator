APCS Logic Final Project Readme

Introduction:
---------------------------------
The purpose of this project is to implement a program that is able to evaluate basic logical expressions and determine if they are valid, satisfiable, or contingent, in addition to determining if one logical expression is equivalent to or entails another logical expression.

Specifications:
---------------------------------
This project fulfills the specifications as required. An LogicalExpression interface with all the required methods (valid, satisfiable contingent, equivalent, entails) are fully implemented in the LogicalExpressionDemo class. However, a constructor taking a String representing a logical sentence is implemented in the LogicalExpressionDemo class, as it is not possible to implement constructors within interfaces. In addition, the required methods correctly evaluate and return the proper values. However, there are some extra credit specifications that were optional and thus not implemented, such as creating a Sentence abstraction, and creating a ThreeValuedVariable.

Current Errors:
---------------------------------
There are currently no errors in the implementation of the code. However, this particular implementation does not utilize the Shunting-Yard algorithm, as suggested, in the process of evaluating a logical expression. In regards to further improvements that can be made, the current implementation is relatively inefficient as it loops through the String several times in order to recurse based on the operator precedence. This could possibly be resolved by using the Shunting-Yard algorithm instead. Additionally, the operators that the program needed to recognize were not specified in the specifications. As such, this program only implements the conjunction, disjunction, and negation operators, in addition to parentheses. The implication and biconditionality operators are not implemented. The program also relies on users using the correct syntax for a logical sentence in order to correctly evaluate it. In addition, the entails and equivalent methods return only -1 or 1, as a case in which 0 would be returned did not seem possible given my current implementation.

Code Overview:
---------------------------------
The general structure of the code involves a separate class implementing the required interface as in the specifications. This LogicalExpressionDemo class implements all the required methods and also includes several of its own methods to aid in the evaluation process. The class consists of several fields, including a String, a StringBuilder, several boolean values, a HashSet, an ArrayList, and a HashMap. These are all used in evaluating the logical sentence. The constructor for the class initializes several of the fields and also invokes the numberOfVars method and test method. The numberOfVars method determines the total number of unique variables in the logical sentence by adding each variable as a character into the HashSet, and initializes the ArrayList field to store the characters from the HashSet in a more easily accessible fashion. The test method iterates through all the possible truth assignment permutations and initializes the HashMap and adds each unique variable from the ArrayList, along with its truth assignment, to the HashMap. The possible truth value permutations are iterated through with the help of bitshifting, and is described in more detail in the actual code documentation. After having obtained the truth assignments for one permutation in the HashMap, the test method then invokes initEval, passing the Hashmap to it. In the initEval method, the sentence's variables are replaced with 'T' or 'F' depending on the assigned truth values obtained from the HashMap. After the sentence has been initialized with these truth values, it is then passed to the evaluate method to be evaluated. The evaluate method evaluates the modified logical sentence with the initialized truth values substituted in place of the variables. It then iterates over the entire sentence twice, looking for the or operator the first time and the and operator the second time. If either operator is found not within a set of parentheses, then both the subsections of the sentence are recursively evaluated, and either the disjunction or conjunction of the two values is returned, for the or/and cases respectively. If neither of these breakpoints are reached, the method then checks for the negation operator and parentheses at the beginning of the sentence and deals with each appropriately. Finally, in the recursive base case, if the sentence length is 1, then the truth value is returned, true for 'T' and false for 'F'. The value returned by the evaluate method is then used to determine validity, satisfiability, and contingency. The equivalent method works by invoking the entails method twice, to check if the current sentence entails the other and if the other also entails the current. In the entails method, evaluation is carried out slightly differently. Since logical entailment involves comparing two different logical sentences, a combinedVariableSet is used to store all the unique variables across both logical sentences. Then, a similar process is used to permute through all the possible truth assignments and assign truth values as in the test method. The method then returns a value depending on whether or not this logical sentence entails the other. More specific description of various parts of the code can be seen in the actual code documentation.

Major Challenges:
---------------------------------
Some major challenges I encountered included having the evaluation work under the case that duplicate variables were present in the logical sentence. This was resolved with the use of a HashMap to assign truth values to a particular variable, and also a HashSet, which allowed determination of the actual number of unique variables in a logical sentence. Additionally, I ran into many pitfalls with evaluating the logical sentences when it came to parentheses. This was eventually resolved by generalizing the code more and considering some generic cases, rather than creating conditionalities for each specific possible case. Yet another challenge in the process of creating this program was that, I was not quite sure how to permute through all the possible truth value assignments for the variables in the logical sentence. This was resolved through bitshifting and bitwise anding values. Overall, this project was quite a didactic experience for me, and I was able to learn quite a bit from my earlier mistakes.

Acknowledgements:
---------------------------------
I would like to thank Albert Ford for providing guidance on the implementation of an evaluation sequence and James Pedersen for his excellent lecture on parsing in general.
